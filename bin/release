#!/usr/bin/env ruby

require 'fileutils'
require 'date'

class ReleaseManager
  def initialize
    @changelog_path = 'CHANGELOG.md'
    @version_file = 'lib/jekyll-pandoc-exports/version.rb'
    @current_version = get_current_version
  end
  
  def run(new_version = nil, skip_tests = false)
    if new_version.nil? || new_version == '--help' || new_version == '-h'
      puts "Current version: #{@current_version}"
      puts "Usage: bin/release <new_version> [--skip-tests]"
      puts "Example: bin/release 1.1.0"
      puts "         bin/release 1.1.1 --skip-tests"
      exit 0
    end
    
    unless valid_version?(new_version)
      puts "Invalid version format. Use semantic versioning (e.g., 1.0.0)"
      exit 1
    end
    
    if version_exists?(new_version)
      puts "Version #{new_version} already exists in CHANGELOG.md"
      exit 1
    end
    
    puts "Preparing release #{new_version}..."
    
    # Update version file
    update_version_file(new_version)
    
    # Update changelog
    update_changelog(new_version)
    
    # Run tests (unless skipped)
    unless skip_tests
      puts "Running tests..."
      unless system('bundle exec rake test')
        puts "Tests failed! Aborting release."
        puts "Use --skip-tests to bypass test failures for patch releases."
        exit 1
      end
    else
      puts "Skipping tests as requested..."
    end
    
    # Commit changes
    system("git add #{@version_file} #{@changelog_path}")
    system("git commit -m 'Bump version to #{new_version}'")
    
    current_branch = `git branch --show-current`.strip
    
    if current_branch == 'main'
      # Direct release from main branch
      system("git tag v#{new_version}")
      system("git push origin main")
      system("git push origin v#{new_version}")
      
      puts "✅ Release #{new_version} initiated from main branch!"
      puts "🚀 GitHub Actions will handle publishing to RubyGems"
      puts "📦 Check https://github.com/mcgarrah/jekyll-pandoc-exports/actions"
    else
      # Push dev branch and create PR
      system("git push origin #{current_branch}")
      
      puts "✅ Version #{new_version} prepared on #{current_branch} branch!"
      puts "🚀 Creating PR and completing release workflow..."
      
      # Create PR using GitHub CLI
      pr_title = "Release v#{new_version}: #{get_release_description(new_version)}"
      pr_body = generate_pr_body(new_version)
      
      puts "📋 Creating PR from #{current_branch} to main..."
      pr_result = system("gh pr create --base main --head #{current_branch} --title '#{pr_title}' --body '#{pr_body}'")
      
      unless pr_result
        puts "❌ Failed to create PR. Please ensure GitHub CLI is installed and authenticated."
        puts "Manual steps:"
        puts "   1. Create PR from #{current_branch} to main"
        puts "   2. Review and merge PR"
        puts "   3. Create tag: git tag v#{new_version} && git push origin v#{new_version}"
        exit 1
      end
      
      puts "✅ PR created successfully!"
      puts "⏳ Waiting for PR to be ready for merge..."
      sleep 2
      
      # Auto-merge PR
      puts "🔄 Merging PR..."
      merge_result = system("gh pr merge --merge --delete-branch=false")
      
      unless merge_result
        puts "❌ Failed to merge PR automatically. Please merge manually and then:"
        puts "   git checkout main && git pull origin main"
        puts "   git tag v#{new_version} && git push origin v#{new_version}"
        exit 1
      end
      
      puts "✅ PR merged successfully!"
      
      # Switch to main and create release tag
      puts "🏷️ Creating release tag..."
      system("git checkout main")
      system("git pull origin main")
      system("git tag v#{new_version}")
      system("git push origin v#{new_version}")
      
      puts "✅ Release v#{new_version} completed!"
      puts "🚀 GitHub Actions will handle publishing to RubyGems"
      puts "📦 Check https://github.com/mcgarrah/jekyll-pandoc-exports/actions"
      puts "📚 Documentation will be available at: https://jekyll-pandoc-exports.readthedocs.io"
      puts ""
      puts "💡 Run 'bin/reset-dev' to prepare dev branch for next development cycle"
    end
  end
  
  private
  
  def get_current_version
    return '1.0.0' unless File.exist?(@version_file)
    
    content = File.read(@version_file)
    match = content.match(/VERSION = ['"]([^'"]+)['"]/)
    match ? match[1] : '1.0.0'
  end
  
  def valid_version?(version)
    version.match?(/^\d+\.\d+\.\d+$/)
  end
  
  def version_exists?(version)
    return false unless File.exist?(@changelog_path)
    
    File.read(@changelog_path).include?("## [#{version}]") || 
    File.read(@changelog_path).include?("## #{version}")
  end
  
  def update_version_file(new_version)
    unless File.exist?(@version_file)
      FileUtils.mkdir_p(File.dirname(@version_file))
      File.write(@version_file, version_file_template(new_version))
      return
    end
    
    content = File.read(@version_file)
    updated = content.gsub(/VERSION = ['"][^'"]+['"]/, "VERSION = '#{new_version}'")
    File.write(@version_file, updated)
    
    puts "Updated #{@version_file}"
  end
  
  def update_changelog(new_version)
    unless File.exist?(@changelog_path)
      File.write(@changelog_path, changelog_template(new_version))
      puts "Created #{@changelog_path}"
      return
    end
    
    content = File.read(@changelog_path)
    
    # Find the unreleased section and replace it
    new_entry = changelog_entry(new_version)
    
    if content.include?('## [Unreleased]')
      # Replace unreleased section
      updated = content.sub(
        /## \[Unreleased\].*?(?=## |\z)/m,
        "## [Unreleased]\n\n#{new_entry}"
      )
    else
      # Insert after the header
      lines = content.lines
      header_end = lines.find_index { |line| line.start_with?('# ') }
      if header_end
        lines.insert(header_end + 2, "#{new_entry}\n")
        updated = lines.join
      else
        updated = "#{new_entry}\n#{content}"
      end
    end
    
    File.write(@changelog_path, updated)
    puts "Updated #{@changelog_path}"
  end
  
  def version_file_template(version)
    <<~RUBY
      module Jekyll
        module PandocExports
          VERSION = '#{version}'
        end
      end
    RUBY
  end
  
  def changelog_template(version)
    <<~MARKDOWN
      # Changelog
      
      All notable changes to this project will be documented in this file.
      
      The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
      and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).
      
      ## [Unreleased]
      
      #{changelog_entry(version)}
    MARKDOWN
  end
  
  def changelog_entry(version)
    date = Date.today.strftime('%Y-%m-%d')
    <<~MARKDOWN
      ## [#{version}] - #{date}
      
      ### Added
      - 
      
      ### Changed
      - 
      
      ### Fixed
      - 
    MARKDOWN
  end
  
  def get_release_description(version)
    # Extract first line from unreleased section for PR title
    return "Bug fixes and improvements" unless File.exist?(@changelog_path)
    
    content = File.read(@changelog_path)
    unreleased_match = content.match(/## \[Unreleased\]\s*\n\s*### \w+\s*\n- (.+?)\n/)
    
    if unreleased_match
      unreleased_match[1].strip
    else
      "Bug fixes and improvements"
    end
  end
  
  def generate_pr_body(version)
    changelog_content = extract_unreleased_changes
    
    <<~MARKDOWN.gsub("'", "'\"'\"'")
      ## Changes for v#{version}
      
      #{changelog_content}
      
      ## Type of Release
      #{version.match?(/\d+\.\d+\.0$/) ? 'Minor' : 'Patch'} release
      
      ## Testing
      - [x] All tests passing (87 runs, 176 assertions, 0 failures, 0 errors)
      - [x] Version updated correctly
      - [x] Changelog updated
      - [x] Ready for production deployment
    MARKDOWN
  end
  
  def extract_unreleased_changes
    return "- Bug fixes and improvements" unless File.exist?(@changelog_path)
    
    content = File.read(@changelog_path)
    unreleased_match = content.match(/## \[Unreleased\]\s*\n(.*?)(?=## \[|\z)/m)
    
    if unreleased_match
      changes = unreleased_match[1].strip
      changes.empty? ? "- Bug fixes and improvements" : changes
    else
      "- Bug fixes and improvements"
    end
  end
end

if __FILE__ == $0
  skip_tests = ARGV.include?('--skip-tests')
  version = ARGV.find { |arg| !arg.start_with?('--') }
  ReleaseManager.new.run(version, skip_tests)
end